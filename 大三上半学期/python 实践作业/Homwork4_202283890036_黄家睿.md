# <center>Homework4</center>
<center>黄家睿</center>
<center>202283890036</center>

在上节课程中，我们学习了类的的封装，继承，多态，正则表达式，异常处理和代码自省等功能，
在本次作业中，我们将运用我们之前写的进化算法的类来添加这些新的功能。

## 封装
将算法的核心逻辑、参数初始化和数据处理操作封装到类中，确保外部代码只能通过类提供的接口访问核心功能。

在本次的作业中，我们讲BWO算法的参数和方法封装在类中，使代码更具结构化。
```
class BWO_CLASS:
    def __init__(self, population_size=300, max_iterations=500,
     objective_function="F9"):
     
......


        print(str(self.objective_function) + " " +
              str(self.max_iterations) + " " +
              str(self.population_size) + " " +
              str(ub) + " " +
              str(lb) + " " +
              str(dim) + " " +
              str(fobj))
```
## 继承的多态

设计父类实现通用的算法框架，子类根据不同的优化需求或目标函数重写部分方法，实现多态性。

子类 BWO_solution 继承了基类 BWO_CLASS，并重写了 BWO_function，实现不同的行为。
```
class BWO_CLASS:

......

def BWO_function(self):
        func_details1 = benchmarks.getFunctionSet(self.objective_function)
        lb = func_details1[1]
        ub = func_details1[2]
        dim = func_details1[3]
        fobj = getattr(benchmarks, self.objective_function)  # 获取函数求解
        print(str(self.objective_function) + " " +
              str(self.max_iterations) + " " +
              str(self.population_size) + " " +
              str(ub) + " " +
              str(lb) + " " +
              str(dim) + " " +
              str(fobj))


#子类BWO—_sulotion 重写了BWO_function方法

class BWO_solution(BWO_CLASS):
    def BWO_function(self):
        func_details1 = benchmarks.getFunctionSet(self.objective_function)
        lb = func_details1[1]
        ub = func_details1[2]
        dim = func_details1[3]
        fobj = getattr(benchmarks, self.objective_function)  # 获取函数求解
        x = BWO.BWO(fobj, lb, ub, dim, self.population_size, self.max_iterations)
```
## 正则表达式
在初始化过程中使用正则表达式验证输入参数的合法性，例如验证目标函数名称是否符合命名规范。

在本次作业中，正则表达式的功能体现在用于验证 objective_function 参数是否只包含合法字符。
```
# 使用正则表达式验证目标函数名称是否符合规范
        if not re.match(r"^[A-Za-z0-9_]+$", objective_function):
            raise ValueError("目标函数名称包含非法字符！")
        self.objective_function = objective_function   
```

## 异常处理
在关键逻辑部分添加异常处理机制，捕获并处理可能出现的运行时错误，避免程序崩溃，同时输出有意义的错误提示。

异常处理功能的添加可以帮助我们捕获函数调用和属性访问中的异常，提供清晰的错误提示。
```
            if fobj is None:
                raise AttributeError(f"目标函数{self.objective_function}在benchmarks模块中未找到！")

            print(f"目标函数: {self.objective_function}, 最大迭代: {self.max_iterations}, 种群数量: {self.population_size}")
            print(f"搜索范围: [{lb}, {ub}], 维度: {dim}")
        except Exception as e:
            print(f"执行BWO_function时发生错误: {e}")
```

## 代码自省
编写代码自省功能，动态检查类和对象的属性与方法，以便调试和验证类的实现是否符合预期。

这部分的功能通过 inspect_class 函数动态检查类的属性和方法。
```
def inspect_class(cls):
    print(f"检查类: {cls.__name__}")
    print(f"方法列表: {[method for method in dir(cls) if callable(getattr(cls, method)) and not method.startswith('__')]}\n")
```